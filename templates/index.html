<!DOCTYPE html>
<html>

<head>
    <title>Soumatou: Audio Memories</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

    <script type="x-shader/x-vertex" id="transVertex">
        varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="transFragment">
        uniform float uTime; uniform float uProgress; varying vec2 vUv;
        float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
        void main() {
            float noise = rand(vUv * 20.0 + uTime * 2.0);
            float dist = distance(vUv, vec2(0.5));
            float vignette = smoothstep(0.2, 0.7, dist);
            float baseAlpha = uProgress * 1.2 + vignette * 0.5;
            float alpha = smoothstep(0.0, 1.0, baseAlpha);
            alpha += (noise - 0.5) * uProgress * 0.1;
            alpha = clamp(alpha, 0.0, 1.0);
            gl_FragColor = vec4(0.0, 0.0, 0.0, alpha); 
        }
    </script>

    <script type="x-shader/x-vertex" id="voidVertex">
      uniform float uTime; uniform float uOpacity; uniform sampler2D uTexture; uniform vec2 uVelocity;
      varying vec3 vColor; varying float vAlpha;
      void main() {
        vec3 pos = position; vec2 uv = uv;
        vec4 texColor = texture2D(uTexture, uv);
        float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
        float dist = distance(uv, vec2(0.5, 0.5));
        float dragInfluence = pow(dist, 1.5); 
        pos.x -= uVelocity.x * dragInfluence * 30.0;
        pos.y -= uVelocity.y * dragInfluence * 30.0;
        float zOffset = brightness * 2.0; 
        float theta = pos.x * 0.2; 
        float radius = 5.0 - zOffset; 
        vec3 curvedPos; curvedPos.x = radius * sin(theta); curvedPos.y = pos.y; curvedPos.z = -radius * cos(theta);
        vec4 mvPosition = modelViewMatrix * vec4(curvedPos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        float sizeBase = 3.0; 
        gl_PointSize = sizeBase * (0.5 + brightness * 2.0) * (5.0 / -mvPosition.z);
        vColor = texColor.rgb * 0.9; 
        float edgeMask = 1.0 - smoothstep(0.4, 0.5, dist);
        vAlpha = brightness * edgeMask * uOpacity;
      }
    </script>
    <script type="x-shader/x-fragment" id="voidFragment">
      varying vec3 vColor; varying float vAlpha;
      void main() {
        vec2 center = gl_PointCoord - 0.5;
        if (length(center) > 0.5) discard;
        if (vAlpha < 0.01) discard;
        gl_FragColor = vec4(vColor, vAlpha * 0.6);
      }
    </script>

    <script type="x-shader/x-vertex" id="photoVertex">
        uniform float uOpacity; 
        uniform sampler2D uTexture;
        uniform float uTime; 
        
        varying vec3 vColor; 
        varying float vAlpha;
        varying vec3 vWorldPos;
  
        void main() {
          vec3 pos = position; 
          vec2 uv = uv;
          vec4 texColor = texture2D(uTexture, uv);
          float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
  
          pos.z += brightness * 0.02; 
  
          // 飘动算法
          float driftX = sin(uTime * 0.5 + uv.y * 3.0) * 0.02; 
          float driftY = cos(uTime * 0.3 + uv.x * 3.0) * 0.02;
          float driftZ = sin(uTime * 0.4 + uv.x * 5.0 + uv.y * 5.0) * 0.15;
          pos.x += driftX; pos.y += driftY; pos.z += driftZ;
  
          vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
          vWorldPos = worldPosition.xyz;
  
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
  
          float sizeBase = 3.0; 
          gl_PointSize = sizeBase * (5.0 / -mvPosition.z);
          
          vColor = texColor.rgb;
  
          // --- [新增] 图片边缘淡出 (Image Vignette) ---
          // 计算粒子距离图片中心的距离
          float distFromCenter = distance(uv, vec2(0.5));
          
          // 创建遮罩：中心(0.0)是1.0，边缘(0.5)是0.0
          // smoothstep(内圈半径, 外圈半径, 当前距离)
          // 0.35 开始衰减，到 0.5 完全透明
          float imgFade = 1.0 - smoothstep(0.35, 0.5, distFromCenter);
  
          // 将边缘淡出遮罩应用到 Alpha
          vAlpha = uOpacity * imgFade;
        }
      </script>

    <script type="x-shader/x-fragment" id="photoFragment">
      varying vec3 vColor; varying float vAlpha;
      varying vec3 vWorldPos; 
      uniform vec3 uCamPos; 
      uniform vec3 uCamDir; 

      void main() {
        vec2 center = gl_PointCoord - 0.5;
        float dist = length(center);
        float circle = 1.0 - smoothstep(0.4, 0.5, dist);
        if (circle < 0.1) discard;

        // 聚光灯 Shader 计算
        vec3 toParticle = normalize(vWorldPos - uCamPos);
        float dotProd = dot(toParticle, uCamDir);
        float spotlight = smoothstep(0.93, 0.99, dotProd);

        gl_FragColor = vec4(vColor, vAlpha * circle * spotlight);
      }
    </script>


    <script>
        // 1. Photo Component (增加音频触发逻辑)
        AFRAME.registerComponent('particle-photo', {
            schema: {
                src: { type: 'string' },
                opacity: { type: 'number', default: 0.0 },
                id: { type: 'int', default: 0 } // [新增] 图片ID
            },
            init: function () {
                const width = 80;
                const height = 60;
                const geometry = new THREE.PlaneBufferGeometry(1.6, 1.2, width, height);
                const textureLoader = new THREE.TextureLoader();

                textureLoader.load(this.data.src, (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            uOpacity: { value: this.data.opacity },
                            uTexture: { value: texture },
                            uTime: { value: 0 },
                            uCamPos: { value: new THREE.Vector3() },
                            uCamDir: { value: new THREE.Vector3(0, 0, -1) }
                        },
                        vertexShader: document.getElementById('photoVertex').textContent,
                        fragmentShader: document.getElementById('photoFragment').textContent,
                        transparent: true,
                        depthWrite: false,
                        blending: THREE.NormalBlending
                    });
                    const points = new THREE.Points(geometry, material);
                    points.frustumCulled = false;
                    this.el.setObject3D('mesh', points);
                    this.material = material;
                });

                this.camPos = new THREE.Vector3();
                this.camDir = new THREE.Vector3();
                this.worldPos = new THREE.Vector3(); // 存储图片自身位置

                // [新增] 状态标记，防止重复发送请求
                this.hasFocus = false;
            },

            update: function () {
                if (this.material && this.material.uniforms) {
                    this.material.uniforms.uOpacity.value = this.data.opacity;
                }
            },

            tick: function (time, delta) {
                // 仅在显示且加载完成时计算
                if (!this.material || !this.material.uniforms) return;

                // 1. 更新时间 (Visuals)
                this.material.uniforms.uTime.value = time / 1000;

                // 2. 更新相机数据 (Visuals)
                let camera = this.el.sceneEl.camera;
                if (!camera) return;

                camera.getWorldPosition(this.camPos);
                camera.getWorldDirection(this.camDir);
                this.material.uniforms.uCamPos.value.copy(this.camPos);
                this.material.uniforms.uCamDir.value.copy(this.camDir);

                // 3. [核心] 音频触发逻辑 (Audio Logic)
                // 如果透明度太低(未显示)，不触发声音
                if (this.data.opacity < 0.5) return;

                // 获取图片的世界坐标中心
                this.el.object3D.getWorldPosition(this.worldPos);

                // 计算向量: 相机 -> 图片中心
                let toImg = this.worldPos.clone().sub(this.camPos).normalize();

                // 计算夹角 (点积)
                let dot = toImg.dot(this.camDir);

                // 阈值判断：0.94 大约对应 20度夹角内的聚光范围
                // 增加一点滞后(hysteresis)防止边缘闪烁: 进0.94, 出0.92
                let thresholdEnter = 0.94;
                let thresholdExit = 0.92;

                if (!this.hasFocus && dot > thresholdEnter) {
                    // 进入视野 -> 发送播放指令
                    this.hasFocus = true;
                    this.sendAudioCmd('focus_enter');
                } else if (this.hasFocus && dot < thresholdExit) {
                    // 离开视野 -> 发送停止指令
                    this.hasFocus = false;
                    this.sendAudioCmd('focus_exit');
                }
            },

            sendAudioCmd: function (actionType) {
                // console.log(`Audio Event: ${actionType} -> ID: ${this.data.id}`);
                fetch('/trigger_effect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: actionType, id: this.data.id })
                }).catch(e => { });
            }
        });

        // 2. Void Particles (不变)
        AFRAME.registerComponent('particle-cloud', {
            init: function () {
                const width = 160, height = 160;
                const geometry = new THREE.PlaneBufferGeometry(8.0, 4.5, width, height);
                const texture = new THREE.CanvasTexture(document.getElementById('canvas-tex'));
                texture.minFilter = THREE.LinearFilter;
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 }, uOpacity: { value: 0.0 },
                        uTexture: { value: texture }, uVelocity: { value: new THREE.Vector2(0, 0) }
                    },
                    vertexShader: document.getElementById('voidVertex').textContent,
                    fragmentShader: document.getElementById('voidFragment').textContent,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.el.setObject3D('mesh', new THREE.Points(geometry, material));
            },
            tick: function (time) {
                let mesh = this.el.getObject3D('mesh');
                if (mesh) mesh.material.uniforms.uTime.value = time / 1000;
            }
        });

        // 3. Head Tracker (不变)
        AFRAME.registerComponent('head-tracker', {
            init: function () {
                this.camEntity = document.querySelector('#main-camera');
                this.startQ = new THREE.Quaternion(); this.currQ = new THREE.Quaternion(); this.diffE = new THREE.Euler();
                this.lastSend = 0;
            },
            resetCenter: function () {
                if (this.camEntity) this.camEntity.object3D.getWorldQuaternion(this.startQ);
            },
            tick: function () {
                if (!this.camEntity) return;
                this.camEntity.object3D.getWorldQuaternion(this.currQ);
                let diff = this.startQ.clone().invert().multiply(this.currQ);
                this.diffE.setFromQuaternion(diff, 'YXZ');

                let mainSystem = document.querySelector('#particle-system');
                if (mainSystem && mainSystem.getAttribute('visible')) {
                    let mesh = mainSystem.getObject3D('mesh');
                    if (mesh && mesh.material.uniforms.uVelocity) {
                        mesh.material.uniforms.uVelocity.value.set(this.diffE.y * 0.2, -this.diffE.x * 0.2);
                    }
                }
                if (Date.now() - this.lastSend > 30) {
                    let tx = Math.max(0, Math.min(1, 0.5 - this.diffE.y));
                    let ty = Math.max(0, Math.min(1, 0.5 + (-this.diffE.x)));
                    fetch('/control', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ x: tx, y: ty })
                    }).catch(e => { });
                    this.lastSend = Date.now();
                }
            }
        });

        // 4. Gallery Generator (传入 ID)
        AFRAME.registerComponent('gallery-generator', {
            schema: {
                count: { type: 'int', default: 10 },
                radius: { type: 'number', default: 2.5 },
                minDist: { type: 'number', default: 0.85 }
            },
            init: function () {
                this.generateGallery();
            },
            generateGallery: function () {
                this.el.innerHTML = '';
                let placedPositions = [];
                let attempts = 0;

                for (let i = 1; i <= this.data.count; i++) {
                    let pos = null;
                    let valid = false;
                    while (!valid && attempts < 500) {
                        attempts++;
                        let angleH = (Math.random() - 0.5) * 180 * (Math.PI / 180);
                        let angleV = (Math.random() - 0.5) * 80 * (Math.PI / 180);
                        let r = this.data.radius + (Math.random() - 0.5) * 0.5;
                        let x = r * Math.sin(angleH) * Math.cos(angleV);
                        let y = r * Math.sin(angleV) + 1.6;
                        let z = -r * Math.cos(angleH) * Math.cos(angleV);
                        let candidate = new THREE.Vector3(x, y, z);
                        let clash = false;
                        for (let existing of placedPositions) {
                            if (candidate.distanceTo(existing) < this.data.minDist) { clash = true; break; }
                        }
                        if (!clash) { pos = candidate; valid = true; placedPositions.push(pos); }
                    }

                    if (pos) {
                        let wrapper = document.createElement('a-entity');
                        wrapper.setAttribute('position', pos);
                        wrapper.classList.add('memory-fragment');

                        // 背景板
                        let bg = document.createElement('a-plane');
                        bg.setAttribute('color', '#000');
                        bg.setAttribute('opacity', '0.4');
                        bg.setAttribute('width', '1.7');
                        bg.setAttribute('height', '1.3');
                        bg.setAttribute('position', '0 0 -0.2');
                        bg.setAttribute('class', 'photo-bg');
                        bg.setAttribute('material', 'transparent: true; opacity: 0');

                        wrapper.appendChild(bg);

                        // [修改] 传入 ID
                        wrapper.setAttribute('particle-photo', `src: /static/img/${i}.jpg; opacity: 0; id: ${i}`);

                        this.el.appendChild(wrapper);
                    }
                }
            }
        });

        // 5. Blur & 6. Video (不变)
        AFRAME.registerComponent('blur-material', {
            init: function () {
                const material = new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 }, uProgress: { value: 0.0 } },
                    vertexShader: document.getElementById('transVertex').textContent,
                    fragmentShader: document.getElementById('transFragment').textContent,
                    transparent: true, side: THREE.BackSide, depthTest: false, depthWrite: false
                });
                let mesh = this.el.getObject3D('mesh');
                if (mesh) { mesh.material = material; mesh.renderOrder = 9999; }
                else { this.el.addEventListener('model-loaded', () => { let m = this.el.getObject3D('mesh'); if (m) { m.material = material; m.renderOrder = 9999; } }); }
            },
            tick: function (time) { let mesh = this.el.getObject3D('mesh'); if (mesh) mesh.material.uniforms.uTime.value = time / 1000; }
        });
        AFRAME.registerComponent('video-canvas', {
            init: function () {
                this.img = document.getElementById('source');
                this.canvas = document.getElementById('canvas-tex');
                this.ctx = this.canvas.getContext('2d');
            },
            tick: function () {
                if (this.img.complete && this.img.naturalHeight > 0) {
                    this.ctx.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);
                    let system = document.querySelector('#particle-system');
                    if (system) { let mesh = system.getObject3D('mesh'); if (mesh) mesh.material.uniforms.uTexture.value.needsUpdate = true; }
                }
            }
        });

        // 7. Transition Controller (不变)
        AFRAME.registerComponent('transition-controller', {
            init: function () {
                this.state = 'REALITY';
                this.sky = document.querySelector('#black-void');
                this.particles = document.querySelector('#particle-system');
                this.transSphere = document.querySelector('#transition-sphere');
                this.lifeReviewContainer = document.querySelector('#life-review-container');

                this.startTime = 0;
                this.duration = 20000;

                this.sendCmd = (act) => {
                    fetch('/trigger_effect', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: act })
                    }).catch(e => console.log(e));
                };

                this.trigger = this.trigger.bind(this);
                this.el.sceneEl.addEventListener('abuttondown', this.trigger);
                this.el.sceneEl.addEventListener('xbuttondown', this.trigger);
                this.sendCmd('stop_heartbeat');
            },

            trigger: function () {
                if (this.state === 'REALITY') {
                    this.state = 'BLURRING';
                    this.startTime = Date.now();
                    this.transSphere.setAttribute('visible', true);
                    let mesh = this.transSphere.getObject3D('mesh');
                    if (mesh && mesh.material.uniforms) mesh.material.uniforms.uProgress.value = 0.0;
                    this.sendCmd('play_heartbeat');
                }
                else if (this.state === 'VOID') {
                    this.enterLifeReview();
                }
                else if (this.state === 'LIFE_REVIEW') {
                    this.returnToReality();
                }
            },

            enterLifeReview: function () {
                console.log("-> Life Review");
                this.state = 'LIFE_REVIEW';

                this.particles.setAttribute('visible', 'false');
                this.transSphere.setAttribute('visible', 'false');

                let cam = document.querySelector('#main-camera');
                if (cam) {
                    let camRot = cam.getAttribute('rotation');
                    this.lifeReviewContainer.setAttribute('rotation', `0 ${camRot.y} 0`);
                    this.lifeReviewContainer.setAttribute('visible', 'true');

                    let children = this.lifeReviewContainer.querySelectorAll('.memory-fragment');
                    let worldCenter = new THREE.Vector3(0, 1.6, 0);

                    children.forEach(el => {
                        el.object3D.updateMatrixWorld(true);
                        el.object3D.lookAt(worldCenter);

                        el.setAttribute('animation', {
                            property: 'particle-photo.opacity',
                            from: 0.0, to: 1.0, dur: 2000, easing: 'easeOutQuad'
                        });
                        let bg = el.querySelector('.photo-bg');
                        if (bg) {
                            bg.setAttribute('animation', {
                                property: 'material.opacity',
                                from: 0.0, to: 0.4, dur: 2000, easing: 'easeOutQuad'
                            });
                        }
                    });
                }

                let tracker = document.querySelector('[head-tracker]').components['head-tracker'];
                if (tracker) tracker.resetCenter();

                this.sendCmd('mode_review');
            },

            returnToReality: function () {
                console.log("-> Reality");
                this.state = 'REALITY';
                this.sky.setAttribute('visible', 'false');
                this.particles.setAttribute('visible', 'false');
                this.lifeReviewContainer.setAttribute('visible', 'false');
                this.transSphere.setAttribute('visible', 'false');
                let mesh = this.transSphere.getObject3D('mesh');
                if (mesh && mesh.material.uniforms) mesh.material.uniforms.uProgress.value = 0.0;

                let photos = document.querySelectorAll('.memory-fragment');
                photos.forEach(el => {
                    // 重置透明度
                    el.setAttribute('particle-photo', 'opacity: 0');
                    // 重置声音触发状态
                    let comp = el.components['particle-photo'];
                    if (comp) comp.hasFocus = false;

                    let bg = el.querySelector('.photo-bg');
                    if (bg) bg.setAttribute('material', 'opacity: 0');
                });
                this.sendCmd('mode_reality');
            },

            tick: function (time) {
                if (this.state !== 'BLURRING') return;
                let elapsed = Date.now() - this.startTime;
                let progress = elapsed / this.duration;
                if (progress < 1.0) {
                    let pulse = Math.sin(elapsed * 0.005) * 0.05;
                    let val = progress + pulse;
                    if (progress > 0.9) val = 1.0;
                    let mesh = this.transSphere.getObject3D('mesh');
                    if (mesh && mesh.material.uniforms) mesh.material.uniforms.uProgress.value = val;
                } else {
                    this.enterVoid();
                }
            },

            enterVoid: function () {
                console.log("-> Void");
                this.state = 'VOID';
                this.sky.setAttribute('visible', 'true');
                this.particles.setAttribute('visible', 'true');
                this.transSphere.setAttribute('visible', 'false');
                let pMesh = this.particles.getObject3D('mesh');
                if (pMesh) pMesh.material.uniforms.uOpacity.value = 1.0;
                let tracker = document.querySelector('[head-tracker]').components['head-tracker'];
                if (tracker) tracker.resetCenter();
                this.sendCmd('mode_void');
            }
        });
    </script>
</head>

<body>
    <img id="source" src="/video_feed" crossorigin="anonymous" style="display:none;">
    <canvas id="canvas-tex" width="1280" height="720" style="display:none;"></canvas>

    <a-scene>
        <a-sky id="black-void" color="#000" radius="4000" visible="false"></a-sky>
        <a-entity id="particle-system" particle-cloud video-canvas position="0 1.6 -2.5" visible="false"></a-entity>
        <a-entity id="life-review-container" position="0 1 0" visible="false"
            gallery-generator="count: 10; minDist: 1.2; radius: 3.0">
        </a-entity>
        <a-entity position="0 1.6 0">
            <a-camera id="main-camera" look-controls="enabled: true" wasd-controls="false">
                <a-entity id="transition-sphere" visible="false"
                    geometry="primitive: sphere; radius: 0.1; segmentsWidth: 32; segmentsHeight: 32" position="0 0 0"
                    blur-material>
                </a-entity>
            </a-camera>
        </a-entity>
        <a-entity oculus-touch-controls="hand: left" transition-controller></a-entity>
        <a-entity oculus-touch-controls="hand: right" transition-controller head-tracker></a-entity>
    </a-scene>
</body>

</html>