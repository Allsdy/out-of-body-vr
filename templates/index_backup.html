<!DOCTYPE html>
<html>

<head>
    <title>Soumatou: 20s Random Transition</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

    <!-- <audio id="snd-heartbeat" src="/static/heartbeat.mp3" loop preload="auto"></audio>
    <audio id="snd-flatline" src="/static/flatline.mp3" preload="auto"></audio> -->

    <script type="x-shader/x-vertex" id="transVertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="transFragment">
        uniform float uTime;
        uniform float uProgress; 
        varying vec2 vUv;

        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            float noise = rand(vUv * 10.0 + uTime);
            float dist = distance(vUv, vec2(0.5));
            float vignette = smoothstep(0.4, 0.8, dist);
            // 混合算法：uProgress 决定整体不透明度，noise 增加抖动感
            float alpha = smoothstep(0.0, 0.8, uProgress + vignette * 0.5);
            alpha += (noise - 0.5) * uProgress * 0.2;
            gl_FragColor = vec4(0.0, 0.0, 0.0, alpha); 
        }
    </script>

    <script type="x-shader/x-vertex" id="vertexShader">
      uniform float uTime; 
      uniform float uOpacity; 
      uniform sampler2D uTexture;
      uniform vec2 uVelocity; 
      
      varying vec3 vColor; 
      varying float vAlpha;

      void main() {
        vec3 pos = position; 
        vec2 uv = uv; 
        
        vec4 texColor = texture2D(uTexture, uv);
        float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));

        float dist = distance(uv, vec2(0.5, 0.5));
        float dragInfluence = pow(dist, 1.5); 
        pos.x -= uVelocity.x * dragInfluence * 40.0;
        pos.y -= uVelocity.y * dragInfluence * 40.0;

        float zOffset = brightness * 2.0; 
        float theta = pos.x * 0.2; 
        float radius = 5.0 - zOffset; 
        
        vec3 curvedPos; 
        curvedPos.x = radius * sin(theta);
        curvedPos.y = pos.y; 
        curvedPos.z = -radius * cos(theta);
        
        vec4 mvPosition = modelViewMatrix * vec4(curvedPos, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        float sizeBase = 3.0; 
        gl_PointSize = sizeBase * (0.5 + brightness * 2.0) * (5.0 / -mvPosition.z);
        vColor = texColor.rgb * 0.9; 
        
        float edgeMask = 1.0 - smoothstep(0.4, 0.5, dist);
        
        vAlpha = brightness * edgeMask * uOpacity;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
      varying vec3 vColor; varying float vAlpha;
      void main() {
        vec2 center = gl_PointCoord - 0.5;
        if (length(center) > 0.5) discard;
        if (vAlpha < 0.01) discard;
        gl_FragColor = vec4(vColor, vAlpha * 0.6);
      }
    </script>

    <script>
        // 1. BLUR MATERIAL
        AFRAME.registerComponent('blur-material', {
            init: function () {
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uProgress: { value: 0.0 }
                    },
                    vertexShader: document.getElementById('transVertex').textContent,
                    fragmentShader: document.getElementById('transFragment').textContent,
                    transparent: true,
                    side: THREE.BackSide,
                    depthTest: false
                });
                let mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material = material;
                } else {
                    this.el.addEventListener('model-loaded', () => {
                        this.el.getObject3D('mesh').material = material;
                    });
                }
            },
            tick: function (time, delta) {
                let mesh = this.el.getObject3D('mesh');
                if (mesh && mesh.material.uniforms) {
                    mesh.material.uniforms.uTime.value = time / 1000;
                }
            }
        });

        // 2. VIDEO CANVAS
        AFRAME.registerComponent('video-canvas', {
            init: function () {
                this.img = document.getElementById('source');
                this.canvas = document.getElementById('canvas-tex');
                this.ctx = this.canvas.getContext('2d');
            },
            tick: function () {
                if (this.img.complete && this.img.naturalHeight > 0) {
                    this.ctx.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);
                    let system = document.querySelector('#particle-system');
                    if (system) {
                        let mesh = system.getObject3D('mesh');
                        if (mesh && mesh.material.uniforms.uTexture.value) {
                            mesh.material.uniforms.uTexture.value.needsUpdate = true;
                        }
                    }
                }
            }
        });

        // 3. PARTICLE CLOUD
        AFRAME.registerComponent('particle-cloud', {
            init: function () {
                const width = 160;
                const height = 160;
                const count = width * height;
                const geometry = new THREE.PlaneBufferGeometry(8.0, 4.5, width, height);
                const canvas = document.getElementById('canvas-tex');
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uOpacity: { value: 0.0 },
                        uTexture: { value: texture },
                        uVelocity: { value: new THREE.Vector2(0, 0) }
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                const points = new THREE.Points(geometry, material);
                this.el.setObject3D('mesh', points);
            },
            tick: function (time, delta) {
                let mesh = this.el.getObject3D('mesh');
                if (mesh) mesh.material.uniforms.uTime.value = time / 1000;
            }
        });

        // 4. HEAD TRACKER
        AFRAME.registerComponent('head-tracker', {
            init: function () {
                this.camEntity = document.querySelector('#main-camera');
                this.position = { x: 0.5, y: 0.5 };
                this.startQuaternion = new THREE.Quaternion();
                this.currentQuaternion = new THREE.Quaternion();
                this.diffEuler = new THREE.Euler();
                this.lastSendTime = 0;
                this.SEND_INTERVAL = 30;
                this.SENSITIVITY_X = 1.0;
                this.SENSITIVITY_Y = 1.0;
                this.isActive = false;
            },
            resetCenter: function () {
                if (!this.camEntity) return;
                this.camEntity.object3D.getWorldQuaternion(this.startQuaternion);
                this.isActive = true;
            },
            disableTracking: function () {
                this.isActive = false;
            },
            tick: function (time, delta) {
                if (!this.isActive || !this.camEntity) return;
                this.camEntity.object3D.getWorldQuaternion(this.currentQuaternion);
                let diffQ = this.startQuaternion.clone().invert().multiply(this.currentQuaternion);
                this.diffEuler.setFromQuaternion(diffQ, 'YXZ');
                let offsetX = this.diffEuler.y * this.SENSITIVITY_X;
                let offsetY = -this.diffEuler.x * this.SENSITIVITY_Y;
                let targetX = 0.5 - offsetX;
                let targetY = 0.5 + offsetY;
                this.position.x = Math.max(0.0, Math.min(1.0, targetX));
                this.position.y = Math.max(0.0, Math.min(1.0, targetY));

                let system = document.querySelector('#particle-system');
                if (system) {
                    let mesh = system.getObject3D('mesh');
                    if (mesh && mesh.material.uniforms.uVelocity) {
                        mesh.material.uniforms.uVelocity.value.set(offsetX * 0.2, offsetY * 0.2);
                    }
                }
                const now = Date.now();
                if (now - this.lastSendTime > this.SEND_INTERVAL) {
                    this.sendPosition();
                    this.lastSendTime = now;
                }
            },
            sendPosition: function () {
                fetch('/control', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ x: this.position.x, y: this.position.y })
                }).catch(e => { });
            }
        });


        // 5. TRANSITION CONTROLLER ( Life Review 循环切换版)
        AFRAME.registerComponent('transition-controller', {
            init: function () {
                this.state = 'REALITY';
                this.sky = document.querySelector('#black-void');
                this.particles = document.querySelector('#particle-system');
                this.transSphere = document.querySelector('#transition-sphere');
                this.lifeReview = document.querySelector('#life-review-stage'); // [新增]

                this.startTime = 0;
                this.duration = 20000; // 20秒过渡

                // 发送指令给 Mac
                this.sendCmd = function (actionName) {
                    fetch('/trigger_effect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action: actionName })
                    }).catch(e => console.log("Audio Trigger Failed:", e));
                };

                this.triggerTransition = this.triggerTransition.bind(this);
                this.el.sceneEl.addEventListener('abuttondown', this.triggerTransition);
                this.el.sceneEl.addEventListener('xbuttondown', this.triggerTransition);

                this.getTracker = () => {
                    let el = document.querySelector('[head-tracker]');
                    return el ? el.components['head-tracker'] : null;
                };

                // 初始化：静音
                console.log("Initializing: Silence...");
                this.sendCmd('stop_heartbeat');
            },

            triggerTransition: function () {
                // 情况 1: 如果是现实，开始去往虚空 (Reality -> Void)
                if (this.state === 'REALITY') {
                    console.log("Go to Void...");
                    this.state = 'BLURRING';
                    this.startTime = Date.now();

                    this.transSphere.setAttribute('visible', true);
                    this.sendCmd('play_heartbeat'); // 开始心跳
                }
                // 情况 2: 如果在虚空 (Particle View)，进入 Life Review Stage
                else if (this.state === 'VOID') {
                    this.enterLifeReview();
                }
                // 情况 3: 如果在 Life Review Stage，回到现实 (Life Review -> Reality)
                else if (this.state === 'LIFE_REVIEW') {
                    this.returnToReality();
                }
                // 情况 4: 如果正在过渡中 (BLURRING)，忽略按键
            },

            returnToReality: function () {
                console.log("Return to Reality!");
                this.state = 'REALITY';

                // 1. 隐藏虚空和 Life Review 元素
                this.sky.setAttribute('visible', 'false');
                this.particles.setAttribute('visible', 'false');
                this.lifeReview.setAttribute('visible', 'false'); // [新增]

                // 2. 重置遮罩球体
                this.transSphere.setAttribute('visible', 'false');
                let mesh = this.transSphere.getObject3D('mesh');
                if (mesh && mesh.material.uniforms) {
                    mesh.material.uniforms.uProgress.value = 0.0;
                }

                // 3. 告诉 Mac 切回现实音效
                this.sendCmd('mode_reality');
            },

            enterLifeReview: function () { // [新增函数]
                console.log("Enter Life Review Stage.");
                this.state = 'LIFE_REVIEW';

                // 1. 隐藏粒子系统 (Particle System)
                this.particles.setAttribute('visible', 'false');

                // 2. 显示 Life Review 图片
                this.lifeReview.setAttribute('visible', 'true');

                // 3. (可选) 保持 VOID 阶段的背景音（闷音+平线声）
                // 如果想切换到安静回顾，可以发送 this.sendCmd('stop_all') 然后播放柔和音乐。
                // 目前保持不变，继续使用 VOID 音效。

                // 4. 重置 Head Tracker 的中心点，让 Life Review 阶段的图片追随头部移动。
                let tracker = this.getTracker();
                if (tracker) tracker.resetCenter();
            },

            tick: function (time, delta) {
                if (this.state !== 'BLURRING') return;

                // --- 过渡动画逻辑 (保持不变) ---
                let elapsed = Date.now() - this.startTime;
                let linearProgress = elapsed / this.duration;

                if (linearProgress < 1.0) {
                    let waveSlow = Math.sin(elapsed * 0.001);
                    // ... (省略复杂的波动计算，保持原样)
                    let waveMed = Math.cos(elapsed * 0.007);
                    let waveFast = Math.sin(elapsed * 0.02);
                    let noise = (waveSlow * 0.1 + waveMed * 0.1 + waveFast * 0.05);
                    let irregularProgress = linearProgress + noise;
                    irregularProgress = Math.max(0.0, Math.min(0.95, irregularProgress));

                    if (linearProgress > 0.9) {
                        let finalPush = (linearProgress - 0.9) * 10.0;
                        irregularProgress = 0.95 + finalPush * 0.05;
                    }

                    let mesh = this.transSphere.getObject3D('mesh');
                    if (mesh && mesh.material.uniforms) {
                        mesh.material.uniforms.uProgress.value = irregularProgress;
                    }
                } else {
                    this.enterVoid();
                }
            },

            enterVoid: function () {
                console.log("Arrived at Void (Particle View).");
                this.state = 'VOID'; // 停留在 VOID 状态，等待下一次按钮触发 Life Review

                // 显示粒子和黑空
                this.sky.setAttribute('visible', 'true');
                this.particles.setAttribute('visible', 'true');

                let pMesh = this.particles.getObject3D('mesh');
                if (pMesh) pMesh.material.uniforms.uOpacity.value = 1.0;

                this.transSphere.setAttribute('visible', 'false');

                let tracker = this.getTracker();
                if (tracker) tracker.resetCenter();

                // 切换音效到虚空模式
                this.sendCmd('mode_void');
            }
        });
    </script>
</head>

<body>

    <img id="source" src="/video_feed" crossorigin="anonymous" style="display:none;">
    <canvas id="canvas-tex" width="1280" height="720" style="display:none;"></canvas>

    <a-scene>
        <a-sky id="black-void" color="#000" radius="4000" visible="false"></a-sky>

        <a-entity id="particle-system" particle-cloud video-canvas position="0 1.6 -2.5" visible="false"></a-entity>

        <a-entity position="0 1.6 0">
            <a-camera id="main-camera" look-controls="enabled: true" wasd-controls="false">
                <a-entity id="transition-sphere" visible="false"
                    geometry="primitive: sphere; radius: 0.2; segmentsWidth: 32; segmentsHeight: 32" position="0 0 0"
                    blur-material>
                </a-entity>
            </a-camera>
        </a-entity>

        <a-entity oculus-touch-controls="hand: left" transition-controller></a-entity>
        <a-entity oculus-touch-controls="hand: right" transition-controller head-tracker></a-entity>

    </a-scene>

</body>

</html>