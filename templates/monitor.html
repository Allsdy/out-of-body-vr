<!DOCTYPE html>
<html>

<head>
    <title>Studio Monitor - Silky Smooth</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .monitor-frame {
            position: relative;
            width: 1280px;
            height: 720px;
            max-width: 90%;
            max-height: 80vh;
            border: 1px solid #333;
            background: #000;
        }

        img#stream {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        #particle-canvas {
            width: 100%;
            height: 100%;
            display: none;
            cursor: grab;
        }

        #particle-canvas:active {
            cursor: grabbing;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.2;
            z-index: 10;
        }

        .crosshair-x {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.3);
        }

        .crosshair-y {
            position: absolute;
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
        }

        .info-bar {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            z-index: 20;
        }

        .btn {
            background: #000;
            color: #666;
            border: 1px solid #333;
            padding: 8px 16px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            transition: 0.2s;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #111;
            color: #fff;
            border-color: #fff;
        }

        .btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .status-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #fff;
            background: #000;
            padding: 2px 6px;
            border: 1px solid #333;
        }
    </style>
</head>

<body>

    <div class="monitor-frame">
        <img id="stream" src="/video_feed" crossorigin="anonymous">
        <div id="particle-canvas"></div>
        <div class="grid-overlay">
            <div class="crosshair-x"></div>
            <div class="crosshair-y"></div>
        </div>
        <div class="status-text">MODE: HYPER-REALITY [FLUID MOTION]</div>
    </div>

    <div class="info-bar">
        <button class="btn active" id="btn-raw" onclick="setMode('raw')">OPTICAL</button>
        <button class="btn" id="btn-particle" onclick="setMode('particle')">DIGITAL</button>
        <span>|</span>
        <button class="btn" onclick="resetPos()">RESET SENSOR</button>
    </div>

    <script>
        // --- 1. 物理控制 (丝滑调教版) ---
        let position = { x: 0.5, y: 0.5 };
        let velocity = { x: 0.0, y: 0.0 };
        let keys = { w: false, a: false, s: false, d: false };

        // 【关键修改】让移动像在冰面/液体中一样顺滑
        const PHYSICS = {
            accel: 0.001,      // 加速度减小：起步更柔和
            friction: 0.94,    // 摩擦力系数增加(接近1)：滑行距离更长，甚至有漂移感
            maxSpeed: 0.035,   // 极速微调：配合高惯性，防止太快晕头
            deadZone: 0.00001  // 死区更小，捕捉微小移动
        };

        let lastSendTime = 0;
        const SEND_INTERVAL = 30; // 30ms 约为 33fps 的同步率

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = true;
            if (k === 's' || k === 'arrowdown') keys.s = true;
            if (k === 'a' || k === 'arrowleft') keys.a = true;
            if (k === 'd' || k === 'arrowright') keys.d = true;
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = false;
            if (k === 's' || k === 'arrowdown') keys.s = false;
            if (k === 'a' || k === 'arrowleft') keys.a = false;
            if (k === 'd' || k === 'arrowright') keys.d = false;
        });

        function resetPos() { position = { x: 0.5, y: 0.5 }; velocity = { x: 0, y: 0 }; sendPosition(); }

        function updatePhysicsLoop() {
            requestAnimationFrame(updatePhysicsLoop);
            if (keys.w) velocity.y -= PHYSICS.accel;
            if (keys.s) velocity.y += PHYSICS.accel;
            if (keys.a) velocity.x -= PHYSICS.accel;
            if (keys.d) velocity.x += PHYSICS.accel;

            velocity.x = Math.max(-PHYSICS.maxSpeed, Math.min(PHYSICS.maxSpeed, velocity.x));
            velocity.y = Math.max(-PHYSICS.maxSpeed, Math.min(PHYSICS.maxSpeed, velocity.y));

            // 摩擦力应用
            velocity.x *= PHYSICS.friction;
            velocity.y *= PHYSICS.friction;

            if (Math.abs(velocity.x) < PHYSICS.deadZone) velocity.x = 0;
            if (Math.abs(velocity.y) < PHYSICS.deadZone) velocity.y = 0;

            position.x += velocity.x; position.y += velocity.y;
            position.x = Math.max(0.0, Math.min(1.0, position.x));
            position.y = Math.max(0.0, Math.min(1.0, position.y));

            const now = Date.now();
            if ((Math.abs(velocity.x) > 0 || Math.abs(velocity.y) > 0) && (now - lastSendTime > SEND_INTERVAL)) {
                sendPosition(); lastSendTime = now;
            }
        }
        function sendPosition() {
            fetch('/control', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ x: position.x, y: position.y })
            }).catch(e => { });
        }
        updatePhysicsLoop();

        // --- 2. 视图切换 ---
        let mode = 'raw';
        let isThreeInit = false;

        function setMode(newMode) {
            mode = newMode;
            const img = document.getElementById('stream');
            const canvas = document.getElementById('particle-canvas');
            const btnRaw = document.getElementById('btn-raw');
            const btnPart = document.getElementById('btn-particle');

            if (mode === 'raw') {
                img.style.display = 'block'; canvas.style.display = 'none';
                btnRaw.classList.add('active'); btnPart.classList.remove('active');
            } else {
                img.style.display = 'none'; canvas.style.display = 'block';
                btnRaw.classList.remove('active'); btnPart.classList.add('active');
                if (!isThreeInit) initThreeJS();
            }
        }

        // --- 3. HYPER-REALITY SHADER (保持不变，因为效果很好) ---
        const vertexShader = `
          uniform float uTime; 
          uniform sampler2D uTexture;
          uniform vec2 uVelocity;
          
          varying vec3 vColor; 
          varying float vAlpha;

          void main() {
            vec3 pos = position; 
            vec2 uv = uv; 
            
            // --- 1. 光谱分离 (RGB Shift) ---
            // 配合丝滑的 velocity，这个色散效果也会变得非常平滑
            float shift = 0.5; 
            vec2 rUV = uv + uVelocity * shift; 
            vec2 bUV = uv - uVelocity * shift;
            
            vec4 texColor = texture2D(uTexture, uv);
            float r = texture2D(uTexture, rUV).r;
            float g = texColor.g;
            float b = texture2D(uTexture, bUV).b;
            
            float brightness = dot(vec3(r,g,b), vec3(0.299, 0.587, 0.114));

            // --- 2. 几何结构 (Lidar Depth) ---
            float zOffset = brightness * 3.0; 
            pos.z += zOffset;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

            // --- 3. 粒子大小 (Square & Sharp) ---
            float sizeBase = 2.5; 
            float distToCam = max(1.0, -gl_Position.z);
            gl_PointSize = sizeBase * (1.0 + brightness * 1.5) * (8.0 / distToCam);
            
            // --- 4. 颜色与托底 ---
            vColor = vec3(r, g, b);
            vColor = pow(vColor, vec3(1.2)) * 1.5;

            if (length(vColor) < 0.1) {
                vColor = vec3(0.05, 0.05, 0.05);
            }
            
            // --- 5. 硬边缘裁切 ---
            float edgeX = step(0.49, abs(uv.x - 0.5));
            float edgeY = step(0.49, abs(uv.y - 0.5));
            vAlpha = 1.0 - max(edgeX, edgeY);
          }
        `;

        const fragmentShader = `
          varying vec3 vColor;
          varying float vAlpha;
          void main() {
            if (vAlpha < 0.1) discard;
            gl_FragColor = vec4(vColor, 1.0); 
          }
        `;

        function initThreeJS() {
            isThreeInit = true;
            const container = document.getElementById('particle-canvas');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
            camera.position.set(0, 0, 3.2);

            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const videoImage = document.getElementById('stream');

            const texture = new THREE.Texture(videoImage);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;

            const pWidth = 512;
            const pHeight = 288;
            const geometry = new THREE.PlaneBufferGeometry(8.0, 4.5, pWidth, pHeight);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uTexture: { value: texture },
                    uVelocity: { value: new THREE.Vector2(0, 0) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });

            const particleMesh = new THREE.Points(geometry, material);
            particleMesh.position.z = -1.0;

            const pivot = new THREE.Group();
            pivot.add(particleMesh);
            scene.add(pivot);

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                if (mode === 'particle') {
                    if (videoImage.complete) {
                        texture.needsUpdate = true;
                    }

                    material.uniforms.uTime.value = clock.getElapsedTime();
                    // 传递丝滑的速度值给 shader
                    material.uniforms.uVelocity.value.set(velocity.x, velocity.y);
                    renderer.render(scene, camera);
                }
            }
            animate();

            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            });

            let isDragging = false;
            let lastX = 0; let lastY = 0;
            container.addEventListener('mousedown', (e) => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
            window.addEventListener('mouseup', () => isDragging = false);
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    pivot.rotation.y += (e.clientX - lastX) * 0.005;
                    pivot.rotation.x += (e.clientY - lastY) * 0.005;
                    lastX = e.clientX; lastY = e.clientY;
                }
            });
        }
    </script>
</body>

</html>